shadow$provide.module$node_modules$base64_js$index = function(global, require, module, exports) {
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw Error("Invalid string. Length must be a multiple of 4");
    }
    b64 = b64.indexOf("\x3d");
    b64 === -1 && (b64 = len);
    return [b64, b64 === len ? 0 : 4 - b64 % 4];
  }
  exports.byteLength = function(b64) {
    b64 = getLens(b64);
    var placeHoldersLen = b64[1];
    return (b64[0] + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  };
  exports.toByteArray = function(b64) {
    var lens = getLens(b64);
    var tmp = lens[0];
    lens = lens[1];
    var arr = new Arr((tmp + lens) * 3 / 4 - lens), curByte = 0, len = lens > 0 ? tmp - 4 : tmp, i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
    }
    lens === 2 && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, arr[curByte++] = tmp & 255);
    lens === 1 && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255);
    return arr;
  };
  exports.fromByteArray = function(uint8$jscomp$0) {
    for (var len = uint8$jscomp$0.length, extraBytes = len % 3, parts = [], i = 0, len2 = len - extraBytes; i < len2; i += 16383) {
      for (var JSCompiler_temp_const = parts, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.push, JSCompiler_inline_result, uint8 = uint8$jscomp$0, end = i + 16383 > len2 ? len2 : i + 16383, output = [], i$jscomp$0 = i; i$jscomp$0 < end; i$jscomp$0 += 3) {
        JSCompiler_inline_result = (uint8[i$jscomp$0] << 16 & 16711680) + (uint8[i$jscomp$0 + 1] << 8 & 65280) + (uint8[i$jscomp$0 + 2] & 255), output.push(lookup[JSCompiler_inline_result >> 18 & 63] + lookup[JSCompiler_inline_result >> 12 & 63] + lookup[JSCompiler_inline_result >> 6 & 63] + lookup[JSCompiler_inline_result & 63]);
      }
      JSCompiler_inline_result = output.join("");
      JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, JSCompiler_inline_result);
    }
    extraBytes === 1 ? (uint8$jscomp$0 = uint8$jscomp$0[len - 1], parts.push(lookup[uint8$jscomp$0 >> 2] + lookup[uint8$jscomp$0 << 4 & 63] + "\x3d\x3d")) : extraBytes === 2 && (uint8$jscomp$0 = (uint8$jscomp$0[len - 2] << 8) + uint8$jscomp$0[len - 1], parts.push(lookup[uint8$jscomp$0 >> 10] + lookup[uint8$jscomp$0 >> 4 & 63] + lookup[uint8$jscomp$0 << 2 & 63] + "\x3d"));
    return parts.join("");
  };
  var lookup = [], revLookup = [], Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  for (global = 0; global < 64; ++global) {
    lookup[global] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[global], revLookup["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(global)] = global;
  }
  revLookup[45] = 62;
  revLookup[95] = 63;
};

//# sourceMappingURL=module$node_modules$base64_js$index.js.map
