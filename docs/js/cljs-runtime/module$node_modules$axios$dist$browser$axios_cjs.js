shadow$provide.module$node_modules$axios$dist$browser$axios_cjs = function(global, require, module, exports) {
  function bind(fn, thisArg) {
    return function() {
      return fn.apply(thisArg, arguments);
    };
  }
  function forEach(obj, fn, {allOwnKeys = !1} = {}) {
    if (obj !== null && typeof obj !== "undefined") {
      var l;
      typeof obj !== "object" && (obj = [obj]);
      if (isArray(obj)) {
        for (allOwnKeys = 0, l = obj.length; allOwnKeys < l; allOwnKeys++) {
          fn.call(null, obj[allOwnKeys], allOwnKeys, obj);
        }
      } else {
        l = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = l.length;
        let key;
        for (allOwnKeys = 0; allOwnKeys < len; allOwnKeys++) {
          key = l[allOwnKeys], fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    obj = Object.keys(obj);
    let i = obj.length, _key;
    for (; i-- > 0;) {
      if (_key = obj[i], key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  function merge() {
    const {caseless} = !isUndefined(this) && this !== _global && this || {}, result = {}, assignValue = (val, key) => {
      key = caseless && findKey(result, key) || key;
      isPlainObject(result[key]) && isPlainObject(val) ? result[key] = merge(result[key], val) : isPlainObject(val) ? result[key] = merge({}, val) : isArray(val) ? result[key] = val.slice() : result[key] = val;
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response, this.status = response.status ? response.status : null);
  }
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    return path ? path.concat(key).map(function(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "") : key;
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  function toFormData(obj, formData, options) {
    function convertValue(value) {
      if (value === null) {
        return "";
      }
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      return utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value) ? useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value) : value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2), value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          return key = removeBrackets(key), arr.forEach(function(el, index) {
            !utils$1.isUndefined(el) && el !== null && formData.append(indexes === !0 ? renderKey([key], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
          }), !1;
        }
      }
      if (isVisitable(value)) {
        return !0;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return !1;
    }
    function build(value, path) {
      if (!utils$1.isUndefined(value)) {
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function(el, key) {
          (!(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers)) === !0 && build(el, path ? path.concat(key) : [key]);
        });
        stack.pop();
      }
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$1.toFlatObject(options, {metaTokens:!0, dots:!1, indexes:!1}, !1, function(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens, visitor = options.visitor || defaultVisitor, dots = options.dots, indexes = options.indexes, useBlob = (options.Blob || typeof Blob !== "undefined" && Blob) && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    const stack = [], exposedHelpers = Object.assign(predicates, {defaultVisitor, convertValue, isVisitable});
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {"!":"%21", "'":"%27", "(":"%28", ")":"%29", "~":"%7E", "%20":"+", "%00":"\x00"};
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    utils$1.isFunction(options) && (options = {serialize:options});
    const serializeFn = options && options.serialize;
    if (params = serializeFn ? serializeFn(params, options) : utils$1.isURLSearchParams(params) ? params.toString() : (new AxiosURLSearchParams(params, options)).toString(_encode)) {
      options = url.indexOf("#"), options !== -1 && (url = url.slice(0, options)), url += (url.indexOf("?") === -1 ? "?" : "\x26") + params;
    }
    return url;
  }
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({visitor:function(value, key, path, helpers) {
      return platform.isNode && utils$1.isBuffer(value) ? (this.append(key, value.toString("base64")), !1) : helpers.defaultVisitor.apply(this, arguments);
    }}, options));
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => match[0] === "[]" ? "" : match[1] || match[0]);
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      var name = path[index++];
      if (name === "__proto__") {
        return !0;
      }
      const isNumericKey = Number.isFinite(+name);
      var isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        return utils$1.hasOwnProp(target, name) ? target[name] = [target[name], value] : target[name] = value, !isNumericKey;
      }
      target[name] && utils$1.isObject(target[name]) || (target[name] = []);
      if (buildPath(path, value, target[name], index) && utils$1.isArray(target[name])) {
        path = name;
        name = target[name];
        value = {};
        index = Object.keys(name);
        const len = index.length;
        let key;
        for (isLast = 0; isLast < len; isLast++) {
          key = index[isLast], value[key] = name[key];
        }
        target[path] = value;
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    return value === !1 || value == null ? value : utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    isHeaderNameFilter && (value = header);
    if (utils$1.isString(value)) {
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => char.toUpperCase() + str);
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach(methodName => {
      Object.defineProperty(obj, methodName + accessorName, {value:function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      }, configurable:!0});
    });
  }
  function transformData(fns, response) {
    const config = this || defaults$1, context = response || config, headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !(!value || !value.__CANCEL__);
  }
  function CanceledError(message, config, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    response.status && validateStatus && !validateStatus(response.status) ? reject(new AxiosError("Request failed with status code " + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response)) : resolve(response);
  }
  function parseProtocol(url) {
    return (url = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url)) && url[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = Array(samplesCount), timestamps = Array(samplesCount);
    let head = 0, tail = 0, firstSampleTS;
    min = min !== void 0 ? min : 1000;
    return function(chunkLength) {
      var now = Date.now();
      const startedAt = timestamps[tail];
      firstSampleTS || (firstSampleTS = now);
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      for (chunkLength = 0; i !== head;) {
        chunkLength += bytes[i++], i %= samplesCount;
      }
      head = (head + 1) % samplesCount;
      head === tail && (tail = (tail + 1) % samplesCount);
      if (!(now - firstSampleTS < min)) {
        return (now = startedAt && now - startedAt) ? Math.round(chunkLength * 1000 / now) : void 0;
      }
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0, threshold = 1000 / freq, lastArgs, timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      timer && (clearTimeout(timer), timer = null);
      fn.apply(null, args);
    };
    return [(...args) => {
      const now = Date.now(), passed = now - timestamp;
      passed >= threshold ? invoke(args, now) : (lastArgs = args, timer || (timer = setTimeout(() => {
        timer = null;
        invoke(lastArgs);
      }, threshold - passed)));
    }, () => lastArgs && invoke(lastArgs)];
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(requestedURL);
    return baseURL && (isRelativeUrl || allowAbsoluteUrls == 0) ? requestedURL ? baseURL.replace(/\/?\/$/, "") + "/" + requestedURL.replace(/^\/+/, "") : baseURL : requestedURL;
  }
  function mergeConfig(config1, config2) {
    function getMergedValue(target, source, prop, caseless) {
      return utils$1.isPlainObject(target) && utils$1.isPlainObject(source) ? utils$1.merge.call({caseless}, target, source) : utils$1.isPlainObject(source) ? utils$1.merge({}, source) : utils$1.isArray(source) ? source.slice() : source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      }
      if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
      if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      }
      if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    config2 = config2 || {};
    const config = {}, mergeMap = {url:valueFromConfig2, method:valueFromConfig2, data:valueFromConfig2, baseURL:defaultToConfig2, transformRequest:defaultToConfig2, transformResponse:defaultToConfig2, paramsSerializer:defaultToConfig2, timeout:defaultToConfig2, timeoutMessage:defaultToConfig2, withCredentials:defaultToConfig2, withXSRFToken:defaultToConfig2, adapter:defaultToConfig2, responseType:defaultToConfig2, xsrfCookieName:defaultToConfig2, xsrfHeaderName:defaultToConfig2, onUploadProgress:defaultToConfig2, 
    onDownloadProgress:defaultToConfig2, decompress:defaultToConfig2, maxContentLength:defaultToConfig2, maxBodyLength:defaultToConfig2, beforeRedirect:defaultToConfig2, transport:defaultToConfig2, httpAgent:defaultToConfig2, httpsAgent:defaultToConfig2, cancelToken:defaultToConfig2, socketPath:defaultToConfig2, responseEncoding:defaultToConfig2, validateStatus:mergeDirectKeys, headers:(a, b, prop) => mergeDeepProperties(a instanceof AxiosHeaders$1 ? {...a} : a, b instanceof AxiosHeaders$1 ? {...b} : 
    b, prop, !0)};
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function(prop) {
      const merge = mergeMap[prop] || mergeDeepProperties, configValue = merge(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  function throwIfCancellationRequested(config) {
    config.cancelToken && config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(config, config.transformRequest);
    ["post", "put", "patch"].indexOf(config.method) !== -1 && config.headers.setContentType("application/x-www-form-urlencoded", !1);
    return adapters.getAdapter(config.adapter || defaults$1.adapter)(config).then(function(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(config, config.transformResponse, response);
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function(reason) {
      isCancel(reason) || (throwIfCancellationRequested(config), reason && reason.response && (reason.response.data = transformData.call(config, config.transformResponse, reason.response), reason.response.headers = AxiosHeaders$1.from(reason.response.headers)));
      return Promise.reject(reason);
    });
  }
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig), instance = bind(Axios$1.prototype.request, context);
    utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys:!0});
    utils$1.extend(instance, context, null, {allOwnKeys:!0});
    instance.create = function(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var process = require("module$node_modules$process$browser"), Buffer = require("module$node_modules$buffer$index").Buffer;
  "use strict";
  const {toString} = Object.prototype, {getPrototypeOf} = Object, {iterator, toStringTag} = Symbol, kindOf = (cache => thing => {
    thing = toString.call(thing);
    return cache[thing] || (cache[thing] = thing.slice(8, -1).toLowerCase());
  })(Object.create(null)), kindOfTest = type => {
    type = type.toLowerCase();
    return thing => kindOf(thing) === type;
  }, typeOfTest = type => thing => typeof thing === type, {isArray} = Array, isUndefined = typeOfTest("undefined"), isArrayBuffer = kindOfTest("ArrayBuffer"), isString = typeOfTest("string"), isFunction = typeOfTest("function"), isNumber = typeOfTest("number"), isObject = thing => thing !== null && typeof thing === "object", isPlainObject = val => {
    if (kindOf(val) !== "object") {
      return !1;
    }
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
  }, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isURLSearchParams = kindOfTest("URLSearchParams"), [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  var JSCompiler_inline_result = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  const _global = JSCompiler_inline_result, isTypedArray = (TypedArray => thing => TypedArray && thing instanceof TypedArray)(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array)), isHTMLForm = kindOfTest("HTMLFormElement"), hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (obj, reducer) => {
    const descriptors = Object.getOwnPropertyDescriptors(obj), reducedDescriptors = {};
    forEach(descriptors, (descriptor, name) => {
      let ret;
      (ret = reducer(descriptor, name, obj)) !== !1 && (reducedDescriptors[name] = ret || descriptor);
    });
    Object.defineProperties(obj, reducedDescriptors);
  }, isAsyncFn = kindOfTest("AsyncFunction"), _setImmediate = ((setImmediateSupported, postMessageSupported) => setImmediateSupported ? setImmediate : postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      source === _global && data === token && callbacks.length && callbacks.shift()();
    }, !1);
    return cb => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : cb => setTimeout(cb))(typeof setImmediate === "function", isFunction(_global.postMessage)), asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  var utils$1 = {isArray, isArrayBuffer, isBuffer:function(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }, isFormData:thing => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  }, isArrayBufferView:function(val) {
    return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(val) : val && val.buffer && isArrayBuffer(val.buffer);
  }, isString, isNumber, isBoolean:thing => thing === !0 || thing === !1, isObject, isPlainObject, isReadableStream, isRequest, isResponse, isHeaders, isUndefined, isDate, isFile, isBlob, isRegExp, isFunction, isStream:val => isObject(val) && isFunction(val.pipe), isURLSearchParams, isTypedArray, isFileList, forEach, merge, extend:(a, b, thisArg, {allOwnKeys} = {}) => {
    forEach(b, (val, key) => {
      thisArg && isFunction(val) ? a[key] = bind(val, thisArg) : a[key] = val;
    }, {allOwnKeys});
    return a;
  }, trim:str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM:content => {
    content.charCodeAt(0) === 65279 && (content = content.slice(1));
    return content;
  }, inherits:(constructor, superConstructor, props, descriptors) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {value:superConstructor.prototype});
    props && Object.assign(constructor.prototype, props);
  }, toFlatObject:(sourceObj, destObj, filter, propFilter) => {
    let props, i, prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) {
      return destObj;
    }
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      for (i = props.length; i-- > 0;) {
        prop = props[i], propFilter && !propFilter(prop, sourceObj, destObj) || merged[prop] || (destObj[prop] = sourceObj[prop], merged[prop] = !0);
      }
      sourceObj = filter !== !1 && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  }, kindOf, kindOfTest, endsWith:(str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    str = str.indexOf(searchString, position);
    return str !== -1 && str === position;
  }, toArray:thing => {
    if (!thing) {
      return null;
    }
    if (isArray(thing)) {
      return thing;
    }
    let i = thing.length;
    if (!isNumber(i)) {
      return null;
    }
    const arr = Array(i);
    for (; i-- > 0;) {
      arr[i] = thing[i];
    }
    return arr;
  }, forEachEntry:(obj, fn) => {
    const _iterator = (obj && obj[iterator]).call(obj);
    let result;
    for (; (result = _iterator.next()) && !result.done;) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  }, matchAll:(regExp, str) => {
    let matches;
    const arr = [];
    for (; (matches = regExp.exec(str)) !== null;) {
      arr.push(matches);
    }
    return arr;
  }, isHTMLForm, hasOwnProperty, hasOwnProp:hasOwnProperty, reduceDescriptors, freezeMethods:obj => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return !1;
      }
      isFunction(obj[name]) && (descriptor.enumerable = !1, "writable" in descriptor ? descriptor.writable = !1 : descriptor.set || (descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      }));
    });
  }, toObjectSet:(arrayOrString, delimiter) => {
    const obj = {}, define = arr => {
      arr.forEach(value => {
        obj[value] = !0;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  }, toCamelCase:str => str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(m, p1, p2) {
    return p1.toUpperCase() + p2;
  }), noop:() => {
  }, toFiniteNumber:(value, defaultValue) => value != null && Number.isFinite(value = +value) ? value : defaultValue, findKey, global:_global, isContextDefined:context => !isUndefined(context) && context !== _global, isSpecCompliantForm:function(thing) {
    return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }, toJSONObject:obj => {
    const stack = Array(10), visit = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            value = visit(value, i + 1);
            !isUndefined(value) && (target[key] = value);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  }, isAsyncFn, isThenable:thing => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch), setImmediate:_setImmediate, asap, isIterable:thing => thing != null && isFunction(thing[iterator])};
  utils$1.inherits(AxiosError, Error, {toJSON:function() {
    return {message:this.message, name:this.name, description:this.description, number:this.number, fileName:this.fileName, lineNumber:this.lineNumber, columnNumber:this.columnNumber, stack:this.stack, config:utils$1.toJSONObject(this.config), code:this.code, status:this.status};
  }});
  const prototype$1 = AxiosError.prototype, descriptors = {};
  "ERR_BAD_OPTION_VALUE ERR_BAD_OPTION ECONNABORTED ETIMEDOUT ERR_NETWORK ERR_FR_TOO_MANY_REDIRECTS ERR_DEPRECATED ERR_BAD_RESPONSE ERR_BAD_REQUEST ERR_CANCELED ERR_NOT_SUPPORT ERR_INVALID_URL".split(" ").forEach(code => {
    descriptors[code] = {value:code};
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", {value:!0});
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function(obj) {
      return obj !== Error.prototype;
    }, prop => prop !== "isAxiosError");
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function(prop) {
    return /^is[A-Z]/.test(prop);
  }), prototype = AxiosURLSearchParams.prototype;
  prototype.append = function(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function(pair) {
      return _encode(pair[0]) + "\x3d" + _encode(pair[1]);
    }, "").join("\x26");
  };
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    use(fulfilled, rejected, options) {
      this.handlers.push({fulfilled, rejected, synchronous:options ? options.synchronous : !1, runWhen:options ? options.runWhen : null});
      return this.handlers.length - 1;
    }
    eject(id) {
      this.handlers[id] && (this.handlers[id] = null);
    }
    clear() {
      this.handlers && (this.handlers = []);
    }
    forEach(fn) {
      utils$1.forEach(this.handlers, function(h) {
        h !== null && fn(h);
      });
    }
  }
  var InterceptorManager$1 = InterceptorManager, transitionalDefaults = {silentJSONParsing:!0, forcedJSONParsing:!0, clarifyTimeoutError:!1}, platform$1 = {isBrowser:!0, classes:{URLSearchParams:typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams, FormData:typeof FormData !== "undefined" ? FormData : null, Blob:typeof Blob !== "undefined" ? Blob : null}, protocols:"http https file blob url data".split(" ")};
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined", _navigator = typeof navigator === "object" && navigator || void 0, hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  var platform = {...Object.freeze({__proto__:null, hasBrowserEnv, hasStandardBrowserWebWorkerEnv:typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function", hasStandardBrowserEnv, navigator:_navigator, origin:hasBrowserEnv && window.location.href || "http://localhost"}), ...platform$1};
  const defaults = {transitional:transitionalDefaults, adapter:["xhr", "http", "fetch"], transformRequest:[function(data, headers) {
    const contentType = headers.getContentType() || "", hasJSONContentType = contentType.indexOf("application/json") > -1, isObjectPayload = utils$1.isObject(data);
    isObjectPayload && utils$1.isHTMLForm(data) && (data = new FormData(data));
    if (utils$1.isFormData(data)) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      return headers.setContentType("application/x-www-form-urlencoded;charset\x3dutf-8", !1), data.toString();
    }
    let isFileList;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        var _FormData = this.env && this.env.FormData;
        return toFormData(isFileList ? {"files[]":data} : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", !1);
      a: {
        if (utils$1.isString(data)) {
          try {
            (0,JSON.parse)(data);
            _FormData = utils$1.trim(data);
            break a;
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        _FormData = (0,JSON.stringify)(data);
      }
      return _FormData;
    }
    return data;
  }], transformResponse:[function(data) {
    var transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing, JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      transitional = !(transitional && transitional.silentJSONParsing) && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (transitional) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }], timeout:0, xsrfCookieName:"XSRF-TOKEN", xsrfHeaderName:"X-XSRF-TOKEN", maxContentLength:-1, maxBodyLength:-1, env:{FormData:platform.classes.FormData, Blob:platform.classes.Blob}, validateStatus:function(status) {
    return status >= 200 && status < 300;
  }, headers:{common:{Accept:"application/json, text/plain, */*", "Content-Type":void 0}}};
  utils$1.forEach("delete get head post put patch".split(" "), method => {
    defaults.headers[method] = {};
  });
  var defaults$1 = defaults;
  const ignoreDuplicateOf = utils$1.toObjectSet("age authorization content-length content-type etag expires from host if-modified-since if-unmodified-since last-modified location max-forwards proxy-authorization referer retry-after user-agent".split(" "));
  var parseHeaders = rawHeaders => {
    const parsed = {};
    let key, val, i;
    rawHeaders && rawHeaders.split("\n").forEach(function(line) {
      i = line.indexOf(":");
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      !key || parsed[key] && ignoreDuplicateOf[key] || (key === "set-cookie" ? parsed[key] ? parsed[key].push(val) : parsed[key] = [val] : parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      function setHeader(_value, _header, _rewrite) {
        var lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw Error("header name must be a non-empty string");
        }
        lHeader = utils$1.findKey(self, lHeader);
        if (!lHeader || self[lHeader] === void 0 || _rewrite === !0 || _rewrite === void 0 && self[lHeader] !== !1) {
          self[lHeader || _header] = normalizeValue(_value);
        }
      }
      const self = this, setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(header.trim())) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
        rewrite = {};
        let dest, key;
        for (const entry of header) {
          if (!utils$1.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          rewrite[key = entry[0]] = (dest = rewrite[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(rewrite, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      if (header = normalizeHeader(header)) {
        var key = utils$1.findKey(this, header);
        if (key) {
          header = this[key];
          if (!parser) {
            return header;
          }
          if (parser === !0) {
            parser = Object.create(null);
            key = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
            let match;
            for (; match = key.exec(header);) {
              parser[match[1]] = match[2];
            }
            return parser;
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, header, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(header);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      return (header = normalizeHeader(header)) ? (header = utils$1.findKey(this, header), !(!header || this[header] === void 0 || matcher && !matchHeaderValue(this, this[header], header, matcher))) : !1;
    }
    delete(header, matcher) {
      function deleteHeader(_header) {
        if (_header = normalizeHeader(_header)) {
          !(_header = utils$1.findKey(self, _header)) || matcher && !matchHeaderValue(self, self[_header], _header, matcher) || (delete self[_header], deleted = !0);
        }
      }
      const self = this;
      let deleted = !1;
      utils$1.isArray(header) ? header.forEach(deleteHeader) : deleteHeader(header);
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length, deleted = !1;
      for (; i--;) {
        const key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, !0)) {
          delete this[key], deleted = !0;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self = this, headers = {};
      utils$1.forEach(this, (value, header) => {
        var key = utils$1.findKey(headers, header);
        key ? (self[key] = normalizeValue(value), delete self[header]) : (key = format ? formatHeader(header) : String(header).trim(), key !== header && delete self[header], self[key] = normalizeValue(value), headers[key] = !0);
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== !1 && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach(target => computed.set(target));
      return computed;
    }
    static accessor(header) {
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        accessors[lHeader] || (buildAccessors(prototype, _header), accessors[lHeader] = !0);
      }
      const accessors = (this[$internals] = this[$internals] = {accessors:{}}).accessors, prototype = this.prototype;
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor("Content-Type Content-Length Accept Accept-Encoding User-Agent Authorization".split(" "));
  utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {get:() => value, set(headerValue) {
      this[mapped] = headerValue;
    }};
  });
  utils$1.freezeMethods(AxiosHeaders);
  var AxiosHeaders$1 = AxiosHeaders;
  utils$1.inherits(CanceledError, AxiosError, {__CANCEL__:!0});
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle(e => {
      const loaded = e.loaded, total = e.lengthComputable ? e.total : void 0, progressBytes = loaded - bytesNotified, rate = _speedometer(progressBytes);
      bytesNotified = loaded;
      listener({loaded, total, progress:total ? loaded / total : void 0, bytes:progressBytes, rate:rate ? rate : void 0, estimated:rate && total && loaded <= total ? (total - loaded) / rate : void 0, event:e, lengthComputable:total != null, [isDownloadStream ? "download" : "upload"]:!0});
    }, freq);
  }, progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [loaded => throttled[0]({lengthComputable, total, loaded}), throttled[1]];
  }, asyncDecorator = fn => (...args) => utils$1.asap(() => fn(...args));
  var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => url => {
    url = new URL(url, platform.origin);
    return origin.protocol === url.protocol && origin.host === url.host && (isMSIE || origin.port === url.port);
  })(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : () => !0, cookies = platform.hasStandardBrowserEnv ? {write(name, value, expires, path, domain, secure) {
    name = [name + "\x3d" + encodeURIComponent(value)];
    utils$1.isNumber(expires) && name.push("expires\x3d" + (new Date(expires)).toGMTString());
    utils$1.isString(path) && name.push("path\x3d" + path);
    utils$1.isString(domain) && name.push("domain\x3d" + domain);
    secure === !0 && name.push("secure");
    document.cookie = name.join("; ");
  }, read(name) {
    return (name = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")\x3d([^;]*)"))) ? decodeURIComponent(name[3]) : null;
  }, remove(name) {
    this.write(name, "", Date.now() - 86400000);
  }} : {write() {
  }, read() {
    return null;
  }, remove() {
  }}, resolveConfig = config => {
    const newConfig = mergeConfig({}, config);
    let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    auth && headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((config = headers.getContentType()) !== !1) {
        const [type, ...tokens] = config ? config.split(";").map(token => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    platform.hasStandardBrowserEnv && (withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig)), (withXSRFToken || withXSRFToken !== !1 && isURLSameOrigin(newConfig.url)) && (config = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName)) && headers.set(xsrfHeaderName, config));
    return newConfig;
  }, xhrAdapter = typeof XMLHttpRequest !== "undefined" && function(config) {
    return new Promise(function(resolve, reject) {
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      function onloadend() {
        if (request) {
          var responseHeaders = AxiosHeaders$1.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
          settle(function(value) {
            resolve(value);
            done();
          }, function(err) {
            reject(err);
            done();
          }, {data:responseType && responseType !== "text" && responseType !== "json" ? request.response : request.responseText, status:request.status, statusText:request.statusText, headers:responseHeaders, config, request});
          request = null;
        }
      }
      const _config = resolveConfig(config);
      let requestData = _config.data;
      var requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let {responseType, onUploadProgress, onDownloadProgress} = _config, onCanceled, flushUpload, flushDownload, request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, !0);
      request.timeout = _config.timeout;
      "onloadend" in request ? request.onloadend = onloadend : request.onreadystatechange = function() {
        request && request.readyState === 4 && (request.status !== 0 || request.responseURL && request.responseURL.indexOf("file:") === 0) && setTimeout(onloadend);
      };
      request.onabort = function() {
        request && (reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request)), request = null);
      };
      request.onerror = function() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        _config.timeoutErrorMessage && (timeoutErrorMessage = _config.timeoutErrorMessage);
        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      "setRequestHeader" in request && utils$1.forEach(requestHeaders.toJSON(), function(val, key) {
        request.setRequestHeader(key, val);
      });
      utils$1.isUndefined(_config.withCredentials) || (request.withCredentials = !!_config.withCredentials);
      responseType && responseType !== "json" && (request.responseType = _config.responseType);
      onDownloadProgress && ([requestHeaders, flushDownload] = progressEventReducer(onDownloadProgress, !0), request.addEventListener("progress", requestHeaders));
      onUploadProgress && request.upload && ([requestHeaders, flushUpload] = progressEventReducer(onUploadProgress), request.upload.addEventListener("progress", requestHeaders), request.upload.addEventListener("loadend", flushUpload));
      if (_config.cancelToken || _config.signal) {
        onCanceled = cancel => {
          request && (reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel), request.abort(), request = null);
        }, _config.cancelToken && _config.cancelToken.subscribe(onCanceled), _config.signal && (_config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled));
      }
      (requestHeaders = parseProtocol(_config.url)) && platform.protocols.indexOf(requestHeaders) === -1 ? reject(new AxiosError("Unsupported protocol " + requestHeaders + ":", AxiosError.ERR_BAD_REQUEST, config)) : request.send(requestData || null);
    });
  }, composeSignals$1 = (signals, timeout) => {
    var {length} = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController(), aborted;
      const onabort = function(reason) {
        aborted || (aborted = !0, unsubscribe(), reason = reason instanceof Error ? reason : this.reason, controller.abort(reason instanceof AxiosError ? reason : new CanceledError(reason instanceof Error ? reason.message : reason)));
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        signals && (timer && clearTimeout(timer), timer = null, signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener("abort", onabort);
        }), signals = null);
      };
      signals.forEach(signal => signal.addEventListener("abort", onabort));
      ({signal:length} = controller);
      length.unsubscribe = () => utils$1.asap(unsubscribe);
      return length;
    }
  };
  const streamChunk = function*(chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
      yield chunk;
    } else {
      for (var pos = 0, end; pos < len;) {
        end = pos + chunkSize, yield chunk.slice(pos, end), pos = end;
      }
    }
  }, readBytes = async function*(iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  }, readStream = async function*(stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
    } else {
      stream = stream.getReader();
      try {
        for (;;) {
          const {done, value} = await stream.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await stream.cancel();
      }
    }
  }, trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator = readBytes(stream, chunkSize);
    let bytes = 0, done$jscomp$0;
    return new ReadableStream({async pull(controller) {
      try {
        const {done, value} = await iterator.next();
        if (done) {
          done$jscomp$0 || (done$jscomp$0 = !0, onFinish && onFinish(void 0)), controller.close();
        } else {
          var len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        }
      } catch (err) {
        throw controller = err, done$jscomp$0 || (done$jscomp$0 = !0, onFinish && onFinish(controller)), err;
      }
    }, cancel(reason) {
      done$jscomp$0 || (done$jscomp$0 = !0, onFinish && onFinish(reason));
      return iterator.return();
    }}, {highWaterMark:2});
  }, isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function", isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function", encodeText = isFetchSupported && (typeof TextEncoder === "function" ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await (new Response(str)).arrayBuffer())), test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return !1;
    }
  }, supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = !1;
    const hasContentType = (new Request(platform.origin, {body:new ReadableStream(), method:"POST", get duplex() {
      duplexAccessed = !0;
      return "half";
    }})).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  }), supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream((new Response("")).body)), resolvers = {stream:supportsResponseStream && (res => res.body)};
  isFetchSupported && (res => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(type => {
      !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? res => res[type]() : (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  const getBodyLength = async body => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      return (await (new Request(platform.origin, {method:"POST", body})).arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    utils$1.isURLSearchParams(body) && (body += "");
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  }, resolveBodyLength = async(headers, body) => {
    headers = utils$1.toFiniteNumber(headers.getContentLength());
    return headers == null ? getBodyLength(body) : headers;
  }, knownAdapters = {http:null, xhr:xhrAdapter, fetch:isFetchSupported && (async config => {
    let {url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, withCredentials = "same-origin", fetchOptions} = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout), request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    var requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {method:"POST", body:data, duplex:"half"}), contentTypeHeader;
        utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type")) && headers.setContentType(contentTypeHeader);
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
          data = trackStream(_request.body, 65536, onProgress, flush);
        }
      }
      utils$1.isString(withCredentials) || (withCredentials = withCredentials ? "include" : "omit");
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url, {...fetchOptions, signal:composedSignal, method:method.toUpperCase(), headers:headers.normalize().toJSON(), body:data, duplex:"half", credentials:isCredentialsSupported ? withCredentials : void 0});
      let response = await fetch(request);
      requestContentLength = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || requestContentLength && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach(prop => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length")), [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), !0)) || [];
        response = new Response(trackStream(response.body, 65536, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }), options);
      }
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType || "text") || "text"](response, config);
      !requestContentLength && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {data:responseData, headers:AxiosHeaders$1.from(response.headers), status:response.status, statusText:response.statusText, config, request});
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request), {cause:err.cause || err});
      }
      throw AxiosError.from(err, err && err.code, config, request);
    }
  })};
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", {value});
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", {value});
    }
  });
  const renderReason = reason => `- ${reason}`, isResolvedHandle = adapter => utils$1.isFunction(adapter) || adapter === null || adapter === !1;
  var adapters = {getAdapter:adapters => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];
    var {length} = adapters;
    let nameOrAdapter, adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter) && (adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()], adapter === void 0)) {
        throw new AxiosError(`Unknown adapter '${id}'`);
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      throw adapters = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === !1 ? "is not supported by the environment" : "is not available in the build")), length = length ? adapters.length > 1 ? "since :\n" + adapters.map(renderReason).join("\n") : " " + `- ${adapters[0]}` : "as no adapter specified", new AxiosError("There is no suitable adapter to dispatch the request " + length, "ERR_NOT_SUPPORT");
    }
    return adapter;
  }, adapters:knownAdapters};
  const validators$1 = {};
  "object boolean number function string symbol".split(" ").forEach((type, i) => {
    validators$1[type] = function(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function(validator, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v1.9.0] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator === !1) {
        throw new AxiosError(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError.ERR_DEPRECATED);
      }
      version && !deprecatedWarnings[opt] && (deprecatedWarnings[opt] = !0, console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future")));
      return validator ? validator(value, opt, opts) : !0;
    };
  };
  validators$1.spelling = function(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return !0;
    };
  };
  var validator = {assertOptions:function(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    for (; i-- > 0;) {
      const opt = keys[i];
      var validator = schema[opt];
      if (validator) {
        const value = options[opt];
        validator = value === void 0 || validator(value, opt, options);
        if (validator !== !0) {
          throw new AxiosError("option " + opt + " must be " + validator, AxiosError.ERR_BAD_OPTION_VALUE);
        }
      } else {
        if (allowUnknown !== !0) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
  }, validators:validators$1};
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {request:new InterceptorManager$1(), response:new InterceptorManager$1()};
    }
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          configOrUrl = {};
          Error.captureStackTrace ? Error.captureStackTrace(configOrUrl) : configOrUrl = Error();
          configOrUrl = configOrUrl.stack ? configOrUrl.stack.replace(/^.+\n/, "") : "";
          try {
            err.stack ? configOrUrl && !String(err.stack).endsWith(configOrUrl.replace(/^.+\n.+\n/, "")) && (err.stack += "\n" + configOrUrl) : err.stack = configOrUrl;
          } catch (e) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      typeof configOrUrl === "string" ? (config = config || {}, config.url = configOrUrl) : config = configOrUrl || {};
      config = mergeConfig(this.defaults, config);
      const {transitional, paramsSerializer, headers} = config;
      transitional !== void 0 && validator.assertOptions(transitional, {silentJSONParsing:validators.transitional(validators.boolean), forcedJSONParsing:validators.transitional(validators.boolean), clarifyTimeoutError:validators.transitional(validators.boolean)}, !1);
      paramsSerializer != null && (utils$1.isFunction(paramsSerializer) ? config.paramsSerializer = {serialize:paramsSerializer} : validator.assertOptions(paramsSerializer, {encode:validators.function, serialize:validators.function}, !0));
      config.allowAbsoluteUrls === void 0 && (config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls !== void 0 ? this.defaults.allowAbsoluteUrls : !0);
      validator.assertOptions(config, {baseUrl:validators.spelling("baseURL"), withXsrfToken:validators.spelling("withXSRFToken")}, !0);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      configOrUrl = headers && utils$1.merge(headers.common, headers[config.method]);
      headers && utils$1.forEach("delete get head post put patch common".split(" "), method => {
        delete headers[method];
      });
      config.headers = AxiosHeaders$1.concat(configOrUrl, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = !0;
      this.interceptors.request.forEach(function(interceptor) {
        if (typeof interceptor.runWhen !== "function" || interceptor.runWhen(config) !== !1) {
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous, requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        }
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      configOrUrl = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        for (promise = Promise.resolve(config); configOrUrl < len;) {
          promise = promise.then(chain[configOrUrl++], chain[configOrUrl++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      chain = config;
      for (configOrUrl = 0; configOrUrl < len;) {
        const onFulfilled = requestInterceptorChain[configOrUrl++], onRejected = requestInterceptorChain[configOrUrl++];
        try {
          chain = onFulfilled(chain);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, chain);
      } catch (error) {
        return Promise.reject(error);
      }
      configOrUrl = 0;
      for (len = responseInterceptorChain.length; configOrUrl < len;) {
        promise = promise.then(responseInterceptorChain[configOrUrl++], responseInterceptorChain[configOrUrl++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }
  utils$1.forEach(["delete", "get", "head", "options"], function(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {method, url, data:(config || {}).data}));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function(method) {
    function generateHTTPMethod(isForm) {
      return function(url, data, config) {
        return this.request(mergeConfig(config || {}, {method, headers:isForm ? {"Content-Type":"multipart/form-data"} : {}, url, data}));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(!0);
  });
  var Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then(cancel => {
        if (token._listeners) {
          for (var i = token._listeners.length; i-- > 0;) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        }
      });
      this.promise.then = onfulfilled => {
        let _resolve;
        onfulfilled = (new Promise(resolve => {
          token.subscribe(resolve);
          _resolve = resolve;
        })).then(onfulfilled);
        onfulfilled.cancel = function() {
          token.unsubscribe(_resolve);
        };
        return onfulfilled;
      };
      executor(function(message, config, request) {
        token.reason || (token.reason = new CanceledError(message, config, request), resolvePromise(token.reason));
      });
    }
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    subscribe(listener) {
      this.reason ? listener(this.reason) : this._listeners ? this._listeners.push(listener) : this._listeners = [listener];
    }
    unsubscribe(listener) {
      this._listeners && (listener = this._listeners.indexOf(listener), listener !== -1 && this._listeners.splice(listener, 1));
    }
    toAbortSignal() {
      const controller = new AbortController(), abort = err => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    static source() {
      let cancel;
      return {token:new CancelToken(function(c) {
        cancel = c;
      }), cancel};
    }
  }
  var CancelToken$1 = CancelToken;
  const HttpStatusCode = {Continue:100, SwitchingProtocols:101, Processing:102, EarlyHints:103, Ok:200, Created:201, Accepted:202, NonAuthoritativeInformation:203, NoContent:204, ResetContent:205, PartialContent:206, MultiStatus:207, AlreadyReported:208, ImUsed:226, MultipleChoices:300, MovedPermanently:301, Found:302, SeeOther:303, NotModified:304, UseProxy:305, Unused:306, TemporaryRedirect:307, PermanentRedirect:308, BadRequest:400, Unauthorized:401, PaymentRequired:402, Forbidden:403, NotFound:404, 
  MethodNotAllowed:405, NotAcceptable:406, ProxyAuthenticationRequired:407, RequestTimeout:408, Conflict:409, Gone:410, LengthRequired:411, PreconditionFailed:412, PayloadTooLarge:413, UriTooLong:414, UnsupportedMediaType:415, RangeNotSatisfiable:416, ExpectationFailed:417, ImATeapot:418, MisdirectedRequest:421, UnprocessableEntity:422, Locked:423, FailedDependency:424, TooEarly:425, UpgradeRequired:426, PreconditionRequired:428, TooManyRequests:429, RequestHeaderFieldsTooLarge:431, UnavailableForLegalReasons:451, 
  InternalServerError:500, NotImplemented:501, BadGateway:502, ServiceUnavailable:503, GatewayTimeout:504, HttpVersionNotSupported:505, VariantAlsoNegotiates:506, InsufficientStorage:507, LoopDetected:508, NotExtended:510, NetworkAuthenticationRequired:511};
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = "1.9.0";
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function(promises) {
    return Promise.all(promises);
  };
  axios.spread = function(callback) {
    return function(arr) {
      return callback.apply(null, arr);
    };
  };
  axios.isAxiosError = function(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === !0;
  };
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode;
  axios.default = axios;
  module.exports = axios;
};

//# sourceMappingURL=module$node_modules$axios$dist$browser$axios_cjs.js.map
